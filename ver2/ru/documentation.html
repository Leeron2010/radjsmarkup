<!doctype html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>RAD-js project</title>
    <link rel="shortcut icon" type="image/x-icon" href="../favicon.ico"/>
	<link rel="stylesheet" href="../css/style.css">
	<link rel="stylesheet" href="../prettify/prettify.css">
</head>
<body>

<div class="header">
	<div class="wrapper">
<!-- 		<div class="language-bar">
	<span>En</span>
	<a href="#">Ru</a>
</div> -->

		<a href="index.html" class="logo-link"></a>
		<span class="menu-link documentation">Documentation</span>
		<!-- <a href="demo.html" class="menu-link demo">Demo</a> -->
	  	<a href="faq.html" class="menu-link faq">FAQ</a>
	  	<a href="contact.html" class="menu-link contact">Contact</a>
	  	<!-- <a href="#" class="menu-link discus">Discus</a> -->
	</div>
</div>

<div class="documentation-wrapper wrapper">
	<div class="side-menu">
        <ul>
            <li><a href="#appObject">Объект приложения</a></li>
            <li><a href="#core">Core</a>
                <ul>
                    <li><a href="#core-method">Методы ядра</a>
                        <ul>
                            <li><a href="#core-method-subscribe">subscribe</a></li>
                            <li><a href="#core-method-publish">publish</a></li>
                            <li><a href="#core-method-unsubscribe">unsubscribe</a></li>
                            <li><a href="#core-method-channels">channels</a></li>
                            <li><a href="#core-method-register">register</a></li>
                            <li><a href="#core-method-registerAll">registerAll</a></li>
                            <li><a href="#core-method-startViewOrService">startViewOrService</a></li>
                            <li><a href="#core-method-startPlugin">startPlugin</a></li>
                            <li><a href="#core-method-stop">stop</a></li>
                            <li><a href="#core-method-startAll">startAll</a></li>
                            <li><a href="#core-method-getView">getView</a></li>
                            <li><a href="#core-method-getStartedView">getStartedView</a></li>
                            <li><a href="#core-method-initialize">initialize</a></li>
                            <li><a href="#core-method-getService">getService</a></li>
                        </ul>
                    </li>
                    <li><a href="#core-property">Свойства ядра</a>
                        <ul>
                            <li><a href="#core-property-plugins">plugins</a></li>
                            <li><a href="#core-property-defaultBackstack">defaultBackstack</a></li>
                            <li><a href="#core-property-backstackType">backstackType</a></li>
                            <li><a href="#core-property-defaultAnimation">defaultAnimation</a></li>
                            <li><a href="#core-property-animationTimeout">animationTimeout</a></li>
                            <li><a href="#core-property-debug">debug</a></li>
                        </ul>
                    </li>
                </ul>
            </li>
            <li><a href="#plagins">Плагины ядра</a>
                <ul>
                    <li><a href="#plagins-navigation">Navigation</a>
                        <ul>
                            <li><a href="#plagins-navigation-show">show</a></li>
                            <li><a href="#plagins-navigation-back">back</a></li>
                            <li><a href="#plagins-navigation-dialog-show">dialog.show</a></li>
                            <li><a href="#plagins-navigation-dialog-close">dialog.close</a></li>
                            <li><a href="#plagins-navigation-toast-show">toast.show</a></li>
                            <li><a href="#plagins-navigation-toast-close">toast.close</a></li>
                            <li><a href="#plagins-navigation-popup-show">popup.show</a></li>
                            <li><a href="#plagins-navigation-popup-close">popup.close</a></li>
                        </ul>
                    </li>
                    <li><a href="#plagins-Fastclick">Fastclick</a></li>
                    <li><a href="#plagins-router">Router</a>
                        <ul>
                            <li><a href="#plagins-router-backstack">backstack</a></li>
                        </ul>
                    </li>
                </ul>
            </li>
            <li><a href="#view">View</a>
                <ul>
                    <li><a href="#view-declaration">Объявление модуля</a></li>
                    <li><a href="#view-methods">Methods</a>
                        <ul>
                            <li><a href="#view-methods-subscribe">subscribe</a></li>
                            <li><a href="#view-methods-unsubscribe">unsubscribe</a></li>
                            <li><a href="#view-methods-publish">publish</a></li>
                            <li><a href="#view-methods-s">$</a></li>
                            <li><a href="#view-methods-finish">finish</a></li>
                            <li><a href="#view-methods-getChildren">getChildren</a></li>
                            <li><a href="#view-methods-bindModel">bindModel</a></li>
                            <li><a href="#view-methods-changeModel">changeModel</a></li>
                            <li><a href="#view-methods-unbindModel">unbindModel</a></li>
                            <li><a href="#view-methods-render">render</a></li>
                            <li><a href="#view-methods-refreshScroll">refreshScroll</a></li>
                        </ul>
                    </li>
                    <li><a href="#view-callbacks">Callbacks</a>
                        <ul>
                            <li><a href="#view-callbacks-onInitialize">onInitialize</a></li>
                            <li><a href="#view-callbacks-onStartRender">onStartRender</a></li>
                            <li><a href="#view-callbacks-onEndRender">onEndRender</a></li>
                            <li><a href="#view-callbacks-onNewExtras">onNewExtras</a></li>
                            <li><a href="#view-callbacks-onStartAttach">onStartAttach</a></li>
                            <li><a href="#view-callbacks-onEndAttach">onEndAttach</a></li>
                            <li><a href="#view-callbacks-onEndDetach">onEndDetach</a></li>
                            <li><a href="#view-callbacks-onDestroy">onDestroy</a></li>
                            <li><a href="#view-callbacks-onReceiveMsg">onReceiveMsg</a></li>
                            <li><a href="#view-callbacks-loader-done">loader.done</a></li>
                        </ul>
                    </li>
                </ul>
            </li>
            <li><a href="#view-properties">Свойства View</a>
                <ul>
                    <li><a href="#view-properties-url">url</a></li>
                    <li><a href="#view-properties-tagname">tagName и ClassName</a></li>
                    <li><a href="#view-properties-children">children</a></li>
                    <li><a href="#view-properties-events">events</a></li>
                    <li><a href="#view-properties-model">model</a></li>
                    <li><a href="#view-properties-other">произвольные свойства</a></li>
                </ul>
            </li>
            <li><a href="#view-animation">Animation</a></li>
            <li><a href="#view-template">Шаблоны</a></li>
            <li><a href="#view-toast">Toast</a></li>
            <li><a href="#view-popup">Popup</a></li>
            <li><a href="#view-scroll">Scrollable view</a></li>
            <li><a href="#view-models">Model</a>
                <ul>
                    <li><a href="#view-models-model">Модель уровня приложения</a></li>
                </ul>
            </li>
            <li><a href="#service">Service</a>
                <ul>
                    <li><a href="#service-declaration">Объявление</a></li>
                    <li><a href="#service-callbacks">Callbacks</a>
                        <ul>
                            <li><a href="#service-callbacks-onInitialize">onInitialize</a></li>
                            <li><a href="#service-callbacks-onDestroy">onDestroy</a></li>
                            <li><a href="#service-callbacks-onReceiveMsg">onReceiveMsg</a></li>
                        </ul>
                    </li>
                </ul>
            </li>
            <li><a href="#namespace">Namespace</a></li>
            <li><a href="#faq">FAQ</a></li>
        </ul>

	</div>
	<div class="docmentation-content">

    <h2 id="appObject">Объект приложения</h2>
    <p>В качестве объекта <strong>application</strong> может выступать любой JS-объект. Он будет доступен в любом модуле (<strong>views</strong> и сервисах) через <strong>this.application</strong>.<br />
        Например: <strong>this.application.logout();</strong> в любом модуле вызовет метод <strong>logout</strong> у объекта <strong>application</strong>.<br />
        Методы у приложения могут быть любыми - просто желательно, чтобы они отображали функциональность приложения (к примеру - залогиниться, вылогиниться, выйти из приложения и т.д.). То есть, принадлежали к уровню абстракции &quot;приложение&quot;, а не к другим уровням, напрмер, &quot;сеть&quot; или &quot;модели&quot;.</p>
    <p>Пример объявления конструктора объекта приложения с использованием методов ядра:</p>

<pre class="prettyprint linenums">
RAD.application(function (core) {
    &#39;use strict&#39;;

    var app = this;

    app.start = function () {
        var options = {
            container_id: &#39;#screen&#39;,
            content: &quot;view.parent_widget&quot;,
            animation: &#39;none&#39;
        };
        core.publish(&#39;navigation.show&#39;, options);
    };

    return app;
});
</pre>

    <p>Обратите внимание, что вторым параметром в <strong>RAD.application</strong> передается булевое значение, которое определяет, создавать или нет экземпляр приложения.</p>
    <p>Стоит заметить, что вызов регистрации приложения можно выполнить только один раз, т.к. это самоопределяющаяся функция. И после этого вызова в пространстве имен <em>RAD.application</em> будет доступен экземпляр Вашего приложения.</p>

    <h2 id="core">Core</h2>
    <ul>
        <li>
            <p>Управление жизненым циклом частей приложения (позволяет добавлять и удалять модули; фактически контролируют загрузку памяти JavaScript-машины);</p>
        </li>
        <li>
            <p>Коммуникационный интерфейс (позволяет частям приложения общаться между собой);</p>
        </li>
        <li>
            <p>Возможность дальнейшего расширения функциональности за счет плагинов.</p>
        </li>
    </ul>

    <h3 id="core-method">Методы ядра</h3>
    <p>К примеру, методы ядра могут вызываться так:</p>

<pre class="prettyprint linenums">
// если ядро доступно(из плагина или на уровне application)
core.publish(&#39;navigation.show&#39;, options);
// для модуля
this.publish(&#39;navigation.show&#39;, options);
</pre>

    <h4 id="core-method-subscribe">subscribe</h4>
<pre class="prettyprint linenums">
subscribe(channel, fn, context);
</pre>

    <p>Подписывает callback-функцию <strong>fn</strong> на выполнение в контексте <strong>context</strong> при получении сообщения по каналу <strong>channel</strong>.</p>
    <p>Модуль автоматически подписывается на сообщения, начинающиеся с &quot;view.&quot; и его ID. Например, модуль, зарегистрированный как <strong>&quot;view.myModule&quot;</strong> при создании автоматически подпишется как на канал &quot;view.myModule&quot;, так и на &quot;view.myModule.doSomeAction&quot;.<br />
        Обрабатывать такие сообщения можно в коллбэке <a href="file:///Users/michail/site/index.html#onReceiveMsg">onReceiveMsg</a>.</p>

    <h4 id="core-method-publish">publish</h4>

<pre class="prettyprint linenums">
publish(channel, data)
</pre>
    <p>Публикует сообщение на канале <strong>channel</strong>, передавая подписчикам объект <strong>data</strong>.</p>
    <p>В случае, если сообщение публикуется на канал &quot;view_ID&quot; некоторого модуля, под которым он зарегистрирован, и если вы не уверены, что этот модуль существует в момент отправки сообщения, то возможно указать <strong>autocreate: true</strong> как одно из полей в данных, передаваемых в канал. В случае необходимости, экземпляр модуля будет создан автоматически.</p>

    <h4 id="core-method-unsubscribe">unsubscribe</h4>
<pre class="prettyprint linenums">
unsubscribe([channel,] context)
</pre>

    <p>Отменяет подписку на канал <strong>channel</strong> в контексте объекта <strong>context</strong>, в котором выполнялся коллбэк. Если в качестве <strong>channel</strong> передан <strong>null</strong>, то данный метод отменяет все подписки объекта.</p>

    <h4 id="core-method-channels">channels</h4>

<pre class="prettyprint linenums">
    channels()
</pre>

    <p>Возвращает существующие каналы сообщений.</p>

    <h4 id="core-method-register">register</h4>

<pre class="prettyprint linenums">
register(viewID/serviceID, fabric)
</pre>

    <p>Регистрирует в ядре модуль с именем <strong>viewID/serviceID</strong> и конструктором <strong>fabric</strong>. Если модуль зарегистрирован автоматически, этот метод не требуется (см. <a href="file:///Users/michail/site/index.html#view">объявление модуля</a>).</p>
    <p>Экземпляр модуля при этом не создается.</p>

    <h4 id="core-method-registerAll">registerAll</h4>

<pre class="prettyprint linenums">
registerAll(arrayOfViews)
</pre>

    <p>Вызывает <a href="file:///Users/michail/site/index.html#register">register</a> для каждого модуля из перечисленных в массиве <strong>arrayOfViews</strong>. Пример массива:</p>

<pre class="prettyprint linenums">
views = [
    {&quot;view.start_page&quot;: view.StartPage},
    {&quot;view.second_page&quot;: view.SecondPage},
],
</pre>

    <p>Обратите внимание, что имена модулей начинаются с <strong>&quot;view.&quot;</strong>, сервисов (модулей без визуального представления) - с <strong>&quot;service.&quot;</strong>.</p>

    <h4 id="core-method-startViewOrService">startViewOrService</h4>

<pre class="prettyprint linenums">
startViewOrService(viewID, [extras])
</pre>

    <p>Создает экземпляр модуля с именем <strong>viewID</strong>; использует объект <strong>extras</strong> в коллбэке самого модуля <a href="file:///Users/michail/site/index.html#onNewExtras">onNewExtras</a>.</p>

    <h4 id="core-method-startPlugin">startPlugin</h4>

<pre class="prettyprint linenums">
startPlugin(pluginID)
</pre>

    <p>Создает экземпляр плагина с именем <strong>pluginID</strong> из списка зарегистрированных плагинов ядра <a href="file:///Users/michail/site/index.html#plugins_list">plugins</a>.</p>

    <h4 id="core-method-stop">stop</h4>

<pre class="prettyprint linenums">
stop(viewID, callback, context)
</pre>

    <p>Останавливает работу модуля с именем <strong>viewID</strong>, после чего выполняет <strong>callback</strong> в контексте объекта <strong>context</strong>.</p>

    <h4 id="core-method-startAll">startAll</h4>

<pre class="prettyprint linenums">
startAll()
</pre>

    <p>Создает экземпляры и запускает все модули.</p>

    <h4 id="core-method-getView">getView</h4>

<pre class="prettyprint linenums">
getView(viewID, [extras])
</pre>

    <p>Возращает экземпляр модуля с именем <strong>viewID</strong>, передавая ему объект <strong>extras</strong> (см. <a href="file:///Users/michail/site/index.html#onNewExtras">onNewExtras</a>). Если экземпляр не создан, инстанциирует его.</p>

    <h4 id="core-method-getStartedView">getStartedView</h4>

<pre class="prettyprint linenums">
getStartedView()
</pre>

    <p>Возвращает массив всех инстанциированных модулей, при этом их видимость на экране не обязательна.</p>

    <h4 id="core-method-initialize">initialize</h4>

<pre class="prettyprint linenums">
initialize(application, options)
</pre>

    <p>Инициализирует ядро параметрами <strong>options</strong> и сохраняет ссылку на объект <strong>application</strong> для последующего внедрения во все модули непосредственной ссылки на приложение.</p>

    <h4 id="core-method-getService">getService</h4>

<pre class="prettyprint linenums">
getService(serviceID, [extras])
</pre>

    <p>Полностью аналогичен методу <a href="file:///Users/michail/site/index.html#getView">getView</a>.</p>

    <h2 id="core-property">Свойства ядра</h3>

    <p>Настройки ядра задаются объектом свойств, например:</p>

<pre class="prettyprint linenums">
coreOptions = {
        plugins: [
            {&quot;plugin.navigator&quot;: plugin.navigation},
            {&quot;plugin.fastclick&quot;: plugin.fastClick},
            {&quot;plugin.router&quot;: plugin.router}
        ],
        defaultBackstack: false,
        backstackType: &#39;native&#39;,
        defaultAnimation: &#39;slide&#39;,
        animationTimeout: 3000,
        debug: false
    };

//initialize core by new application object
core.initialize(application, coreOptions);
</pre>

    <h4 id="core-property-plugins">plugins</h4>

<pre class="prettyprint linenums">
plugins: [
    {&quot;plugin.navigator&quot;: plugin.navigation},
    {&quot;plugin.fastclick&quot;: plugin.fastClick},
    {&quot;plugin.router&quot;: plugin.router}
],
</pre>

    <p>Массив подключаемых плагинов. На данный момент плагинами реализованы роутер, layout manager и кроссбраузерные события для touch-устройств (&quot;tap&quot;, &quot;swipe&quot; и др.). Подробнее об этом в разделе <a href="file:///Users/michail/site/index.html#plugins">plugins</a>.</p>
    <p>Обратите внимание, что плагины <strong>&quot;plugin.navigator&quot;, &quot;plugin.fastclick&quot;, &quot;plugin.router&quot;</strong> уже зарегистрированы, и специально передавать их через список нет необходимости.</p>

    <h4 id="core-property-defaultBackstack">defaultBackstack</h4>

<pre class="prettyprint linenums">
// no backstack
defaultBackstack: false,
// backstack enabled
defaultBackstack: true,
</pre>

    <p>Бэкстек по умолчанию для <strong>всех</strong> транзакций. При установке <strong>false</strong> история изменений содержимого экрана (смены расположения views) запоминаться не будет. Чтобы внести в историю отдельную транзакцию, нужно использовать опцию <strong>backstack: true</strong> при использовании <a href="file:///Users/michail/site/index.html#navigation_plugin">navigation</a>.<br />
        Подробнее о бэкстеке в разделе <a href="file:///Users/michail/site/index.html#router_backstack">Backstack</a>.</p>

    <h4 id="core-property-backstackType">backstackType</h4>

<pre class="prettyprint linenums">
//backstack с использованием history API
backstackType: &#39;native&#39;
//backstack с использованием hash-ссылок для history API
backstackType: &#39;hashbang&#39;
//внутренняя реализация backstack
backstackType: &#39;custom&#39;
</pre>

    <p>Тип бэкстека для всех транзакций. Если значение этого свойства не определено, тип бэкстека будет выбран автоматически (&#39;<strong>native</strong>&#39; либо &#39;<strong>hashbang</strong>&#39;, в зависимости от браузера). Подробнее о типах бэкстека в разделе <a href="file:///Users/michail/site/index.html#router_backstack">Backstack</a>.</p>

    <h4 id="core-property-defaultAnimation">defaultAnimation</h4>

<pre class="prettyprint linenums">
defaultAnimation: &#39;slide&#39;,
</pre>

    <p>Анимация смены модулей по умолчанию. Может принимать значения <strong>&#39;slide&#39;</strong> (сдвиг), <strong>&#39;fade&#39;</strong> (затухание) и <strong>&#39;none&#39;</strong> (мгновенное замещение). Подробнее - <a href="file:///Users/michail/site/index.html#animation">анимация модулей</a>.</p>

    <h4 id="core-property-animationTimeout">animationTimeout</h4>

<pre class="prettyprint linenums">
animationTimeout: 3000,
</pre>

    <p>Время, через которое будет снята блокировка интерфейса (включается при начале анимации) в случае непредвиденных ошибок.</p>

    <h4 id="core-property-debug">debug</h4>

<pre class="prettyprint linenums">
debug: false
</pre>

    <p>Режим отладки. При установке <strong>true</strong> пишет в консоль браузера информацию о событиях, объектах ядра и каналах.</p>

    <h2 id="plagins">Плагины ядра</h2>

    <p>Плагины реализуют дополнительный функционал ядра, необходимый для работы системы и не зависящий от конкретной реализации логики приложения. Если нужно реализовать функциональный модуль без визуального представления в конкретном приложении, рекомендуется использовать сервисы.</p>

    <h3 id="plagins-navigation">Navigation</h3>

    <p>Плагин navigation обрабатывает все сообщения с корневым узлом <strong>&#39;navigation.&#39;</strong> и занимается управлением views (отображение, скрытие, обеспечение бэкстека и нотификация об изменении состояния).</p>

    <h4 id="plagins-navigation-show">show</h4>

<pre class="prettyprint linenums">
var options = {
    container_id: &#39;#screen&#39;,
    content: &quot;view.start_page&quot;,
    animation: &quot;none&quot;,
    backstack: false,
    callback: null,
    context: null,
    extras: null

}
this.publish(&#39;navigation.show&#39;, options);
</pre>

    <p>Отображает указанный в <strong>options.content</strong> модуль в контейнере <strong>options.container_id</strong> (CSS-селектор). Параметры <strong>options</strong>:</p>

    <ul>
        <li>
            <p><strong>content</strong> - зарегистрированное имя модуля (<strong>viewID</strong>), который будет отображен;</p>
        </li>
        <li>
            <p><strong>container_id</strong> - селектор элемента-контейнера для отображения модуля;</p>
        </li>
        <li>
            <p><strong>animation</strong> - <a href="file:///Users/michail/site/index.html#animation">анимация</a>, используемая при смене view в указанном контейнере;</p>
        </li>
        <li>
            <p><strong>backstack</strong> - сохранить историю изменения положения модулей (<strong>true</strong> или <strong>false</strong>);</p>
        </li>
        <li>
            <p><strong>callback</strong> - функция, которая будет выполнена по завершении отображения модуля <strong>content</strong>;</p>
        </li>
        <li>
            <p><strong>context</strong> - контекст выполнения для <strong>callback</strong>;</p>
        </li>
        <li>
            <p><strong>extras</strong> - см. <a href="file:///Users/michail/site/index.html#onNewExtras">OnNewExtras</a>.</p>
        </li>
    </ul>

    <p>Обязательные параметры - <strong>content</strong> и <strong>container_id</strong> (последний для toast.show и dialog.show не обязателен). Остальные параметры не обязательны.</p>

    <h4 id="plagins-navigation-back">back</h4>

<pre class="prettyprint linenums">
this.publish(&#39;navigation.back&#39;, options);
</pre>

    <p>Аналогичен <strong>navigation.show</strong>. При этом по умолчанию используется обратная анимация.</p>

    <h4 id="plagins-navigation-dialog-show">dialog.show</h4>

<pre class="prettyprint linenums">
this.publish(&#39;navigation.dialog.show&#39;, options);
</pre>

    <p>Аналогичен <strong>navigation.show</strong>, но показывает модуль, как модальное окно. Может быть закрыт при помощи <a href="file:///Users/michail/site/index.html#navigation_dialog_close">dialog.close</a>.</p>

    <h4 id="plagins-navigation-dialog-close">dialog.close</h4>

<pre class="prettyprint linenums">
this.publish(&#39;navigation.dialog.close&#39;, options);
</pre>

    <p>Закрывает модальное окно.</p>

    <h4 id="plagins-navigation-toast-show">toast.show</h4>

<pre class="prettyprint linenums">
options = {
    content: &quot;view.toast&quot;,
    gravity: &#39;left&#39;,
};

this.publish(&#39;navigation.toast.show&#39;, options);
</pre>

    <p>Показывает модуль как оповещение, закрывающееся автоматически (по умолчанию - через 3 секунды) или по клику.<br />
        Параметр <strong>options.gravity</strong> - положение, принимает значения <strong>center</strong> (в центре экрана), <strong>left</strong> (прижат к левому краю), <strong>right </strong>(прижат к правому краю), <strong>top</strong> (низ экрана) и <strong>bottom</strong> (верх).</p>

    <p>Обязательное условие - view должно быть унаследовано от <strong>RAD.Blanks.Toast</strong>.</p>

    <h4 id="plagins-navigation-toast-close">toast.close</h4>

<pre class="prettyprint linenums">
this.publish(&#39;navigation.toast.close&#39;, options);
</pre>

    <p>Закрывает оповещение.</p>

    <h4 id="plagins-navigation-popup-show">popup.show</h4>

<pre class="prettyprint linenums">
options = {
        content: &quot;view.popup&quot;,

        target: document.getElementById(targetID),
        width: 180,
        height: 200,
        gravity: &#39;right&#39;,

    };

this.publish(&#39;navigation.popup.show&#39;, options);
</pre>

    <p>Показывает модуль как неблокирующее всплывающее окно, которое может закрываться автоматически по клику вне его. Свойства options:</p>
    <ul>
        <li>
            <p><strong>target</strong>: элемент, относительно которого позиционируется popup;</p>
        </li>
        <li>
            <p><strong>gravity</strong>: положение относительно <strong>target</strong>; принимает значения <strong>none</strong> (направление выбирается автоматически), <strong>center</strong> (в центре экрана), <strong>left</strong>, <strong>right</strong>, <strong>top</strong> и <strong>bottom</strong></p>

            
        </li>
    </ul>

    <p>Обязательное условие - view должен быть унаследован от <strong>RAD.Blanks.Popup</strong>.</p>

    <h4 id="plagins-navigation-popup-close">popup.close</h4>

<pre class="prettyprint linenums">
this.publish(&#39;navigation.popup.close&#39;, options);
</pre>

    <p>Закрывает всплывающее окно.</p>

    <h2 id="plagins-Fastclick">Fastclick</h3>

    <p>Плагин ядра, реализующий кроссбраузерные события &laquo;swipe&raquo;, &laquo;tap&raquo;, &laquo;tapdown&raquo;, &laquo;tapup&raquo;, &laquo;tapmove&raquo;, &laquo;tapcancel&raquo;</p>

    <h2 id="plagins-router">Router</h3>

    <p>Используется ядром для навигации, реализует backstack.</p>

    <h4 id="plagins-router-backstack">backstack</h4>

<pre class="prettyprint linenums">
options = {
    backstack: true,
}
</pre>

    <p>Компонент плагина <strong>router</strong>, позволяющий динамически запоминать расположение (т.е. layout) views на экране для конкретной сессии, используя <em>history API</em> браузера, либо внутреннюю реализацию, и таким образом позволяющий возвращаться к предыдущим расположениям модулей. <strong>backstack</strong> не является аналогом <em>Routers</em> в <strong>Backbone.js</strong> или <strong>Angular.js</strong>. В плагине реализованы три типа бэкстека (<strong>backstackType</strong>):</p>
    <ul>
        <li>
            <p><strong>native</strong> - бэкстек с использованием <em>history API</em> браузера;</p>
        </li>
        <li>
            <p><strong>hashbang</strong> - бэкстек с использованием генерации <strong>hash</strong>-ссылки (для браузеров, не поддерживающих <strong>history.pushState</strong>);</p>
        </li>
        <li>
            <p><strong>custom</strong> - внутренняя реализация (без использования <em>history API</em>).</p>
        </li>
    </ul>

    <p>Если параметр <strong>defaultBackstack</strong> в настройках <strong>Core</strong> установлен как <strong>false</strong>, то для использования бэкстека достаточно указать параметр <strong>backstack: true</strong> в <a href="file:///Users/michail/site/index.html#navigation_show">запросе на смену views</a>; таким образом, следующее расположение views на экране сохранится. Перемещение назад по стеку осуществляется:</p>

    <ul>
        <li>
            <p>кнопками браузера &quot;Back&quot; и &quot;Forward&quot;, либо вызовом <strong>history.back()</strong> (для типов бэкстека <strong>&#39;native&#39;</strong> и <strong>&#39;hashbang&#39;</strong>);</p>
        </li>
        <li>
            <p>публикацией сообщения <strong>&#39;router.back&#39;</strong> (для всех типов)</p>
        </li>
    </ul>

<pre class="prettyprint linenums">
history.back(); // backstackType: &#39;native&#39; или &#39;hashbang&#39;
this.publish(&#39;router.back&#39;, null); // любой backstackType
</pre>

    <p><strong>Router</strong> подписан на следующие сообщения:</p>

    <ul>
        <li>
            <p><strong>&#39;router.clear&#39;</strong> - при получении сообщения удаляет всю историю навигации данной сессии (опустошает бэкстек);</p>
        </li>
        <li>
            <p><strong>&#39;router.back&#39;</strong> - при получении сообщения вызывает возврат на один шаг назад по бэкстеку;</p>
        </li>
        <li>
            <p><strong>&#39;router.beginTransition&#39;</strong> - сообщение публикуется плагином <strong>navigation</strong> перед началом анимации (transition) смены <strong>view</strong>;</p>
        </li>
        <li>
            <p><strong>&#39;router.endTransition&#39;</strong> - сообщение публикуется плагином <strong>navigation</strong>, когда анимация смены <strong>view</strong> завершена. При этом происходит добавление URL предыдущего положения модулей в history (бэкстек-типы <strong>&#39;native&#39;</strong>, <strong>&#39;hashbang&#39;</strong>), либо внутренний стек (<strong>&#39;custom&#39;</strong>)</p>
        </li>
    </ul>

<pre class="prettyprint linenums">
this.publish(&#39;router.clear&#39;, null); //обнуление существующего backstack
this.publish(&#39;router.back&#39;, null); //возврат назад по backstack
</pre>

    <p><strong>Router</strong> публикует следующие сообщения:</p>

    <ul>
        <li>
            <p><strong>&#39;backstack.pop&#39;</strong> - сообщение публикуется в момент, когда происходит возврат назад по бэкстеку;</p>
        </li>
        <li>
            <p><strong>&#39;backstack.empty&#39;</strong> - сообщение публикуется в момент опустошения бэкстека.</p>
        </li>
    </ul>

    <p>Пример использования backstack:</p>

<pre class="prettyprint linenums">
RAD.view(&quot;view.screen_1&quot;, RAD.Blanks.View.extend({
    url: &#39;source/views/screen_1/screen_1.html&#39;,
    events: {
        &#39;tap button.next-scr&#39;: &#39;open&#39;
    }
    open: function () {
        this.publish(&#39;navigation.show&#39;, {
            content: &#39;view.screen_2&#39;,
            container_id: &#39;#content&#39;,
            backstack: true
            //по завершению смены view будет сохранен URL, соответствующий их текущему расположению
        });
    }
}));

RAD.view(&quot;view.screen_2&quot;, RAD.Blanks.View.extend({
    url: &#39;source/views/screen_2/screen_2.html&#39;,
    events: {
        &#39;tap button.next-scr&#39;: &#39;open&#39;
    }
    open: function () {
        this.publish(&#39;navigation.show&#39;, {
            content: &#39;view.screen_3&#39;,
            container_id: &#39;#content&#39;,
            backstack: true
            //по завершению смены view будет сохранен URL, соответствующий их текущему расположению
        });
    }
}));

RAD.view(&quot;view.top_widget&quot;, RAD.Blanks.View.extend({
    className: &#39;block&#39;,
    url: &#39;source/views/top_widget/top_widget.html&#39;,
    events: {
        &#39;tap button.go-back&#39;: &#39;goBack&#39;
    },
    goBack: function () {
        &quot;use strict&quot;;
        this.publish(&#39;router.back&#39;, null); //возврат к последнему сохраненному расположению модулей
    }
}));
</pre>

    <h2 id="view">View</h2>

    <p>Основа для конструктора view в приложении; представляет собой расширенный <strong>backbone.view</strong>.</p>

    <h2 id="view-declaration">Объявление модуля</h3>

    <p>Пример файла модуля start_page.js, объявление view через шаблон &#39;namespace&#39;:</p>

<pre class="prettyprint linenums">
RAD.views.StartPage = RAD.Blanks.View.extend({
    url: &#39;source/views/start_page.html&#39;
})
</pre>

    <p>Обратите внимание, что при таком объявлении необходимо использовать регистрацию view <a href="file:///Users/michail/site/index.html#register">register</a>, чтобы модуль был доступен ядру. Рекомендуется использовать способ объявления модулей, представленный ниже.</p>

<pre class="prettyprint linenums">
    RAD.view(&quot;view.start_page&quot;, RAD.Blanks.View.extend({
        url: &#39;source/views/start_page.html&#39;
    }));
</pre>

    <h3 id="view-methods">Methods</h3>

    <h4 id="view-methods-subscribe">subscribe</h4>

<pre class="prettyprint linenums">
this.subscribe(channel, function, context);
</pre>

    <p>Подписывает данный экземпляр модуля на указанный канал; является прямой ссылкой на метод ядра <a href="file:///Users/michail/site/index.html#subscribe">subscribe</a>.</p>

    <h4 id="view-methods-unsubscribe">unsubscribe</h4>

<pre class="prettyprint linenums">
this.unsubscribe([channel,] context);
</pre>

    <p>Отписывает данный экземпляр модуля от указанного канала; является прямой ссылкой на метод ядра <a href="file:///Users/michail/site/index.html#unsubscribe">unsubscribe</a>.</p>

    <h4 id="view-methods-publish">publish</h4>

<pre class="prettyprint linenums">
this.publish(channel, data);
</pre>

    <p>Публикует сообщение, содержащее данные <strong>data</strong>, в указанный канал <strong>channel</strong>; является прямой ссылкой на метод ядра <a href="file:///Users/michail/site/index.html#publish">publish</a>.</p>

    <h4 id="view-methods-s">$</h4>

<pre class="prettyprint linenums">
this.$(&#39;css_selector&#39;);
</pre>

    <p>Ищет указанный CSS-селектор в данном модуле и оборачивает найденный елемент в JQuery. Аналог:</p>

<pre class="prettyprint linenums">
this.$el.find(&#39;css_selector&#39;);
</pre>

    <h4 id="view-methods-finish">finish</h4>

<pre class="prettyprint linenums">
this.finish();
</pre>

    <p>Уничтожает данный экземпляр модуля.</p>

    <h4 id="view-methods-getChildren">getChildren</h4>

<pre class="prettyprint linenums">
this.getChildren();
</pre>

    <p>Возвращает массив дочерних модулей, заданных при объявлении в <a href="file:///Users/michail/site/index.html#children">children</a>, или находящихся в данный момент в этом view.</p>

    <h4 id="view-methods-bindModel">bindModel</h4>

<pre class="prettyprint linenums">
this.bindModel(model);
</pre>

    <p>Устанавливает <a href="file:///Users/michail/site/index.html#model">модель</a> для модуля. При этом будет вызван <a href="file:///Users/michail/site/index.html#render">render()</a> для перерисовки модуля. Модуль будет автоматически подписан на события модели.</p>

    <h4 id="view-methods-changeModel">changeModel</h4>

<pre class="prettyprint linenums">
this.changeModel(model);
</pre>

    <p>Заменяет <a href="file:///Users/michail/site/index.html#model">модель</a> модуля на переданную в <strong>model</strong>. При этом будет вызван <a href="file:///Users/michail/site/index.html#render">render()</a> для перерисовки модуля.</p>

    <h4 id="view-methods-unbindModel">unbindModel</h4>

<pre class="prettyprint linenums">
this.unbindModel(forceRender);
</pre>

    <p>Удаляет <a href="file:///Users/michail/site/index.html#model">модель</a> модуля. Если параметр равен true, то при этом будет вызван <a href="file:///Users/michail/site/index.html#render">render()</a> для перерисовки модуля.</p>

    <p>Обратите внимание, что если в шаблоне не проверяется наличие модели, вызов метода может вызвать ошибку. Рекомендуется использовать только в крайнем случае, если задача иначе не решаема.</p>

    <h4 id="view-methods-render">render</h4>

<pre class="prettyprint linenums">
this.render();
</pre>

    <p>Перерисовывает содержимое модуля.</p>

    <p>Обычно вызов этого метода вручную не требуется.</p>

    <h4 id="view-methods-refreshScroll">refreshScroll</h4>

<pre class="prettyprint linenums">
this.refreshScroll();
</pre>

    <p>Обновляет границы скроллящегося контента для правильного отображения прокрутки.</p>

    <p>Обычно вызов этого метода вручную не требуется. Может понадобиться только в случае ручной вставки контента в элемент модуля, что не рекомедуется.</p>

    <h3 id="view-callbacks">Callbacks</h3>

    <p>Коллбэки описываются при объявлении view, например:</p>

<pre class="prettyprint linenums">
RAD.view(&quot;view.start_page&quot;, RAD.Blanks.View.extend({
    url: &#39;source/views/start_page.html&#39;,
    onEndRender: function () {
        &quot;use strict&quot;;
        console.log(&#39;page rendered!&#39;);
    }
}));
</pre>

    <p>Представляют собой функции, вызываемые при событиях жизненого цикла view:</p>

<pre class="prettyprint linenums">
 // выполняется во время создания экземпляра
onInitialize: function () {},

// выполняется при получении view данных через navigator
onNewExtras: function () {},

// выполняется при получении сообщения на канал, совпадающий с viewID
onReceiveMsg: function () {},

// выполняется перед началом шаблонизации(создания html view)
onStartRender: function () {},

// выполняется после создания html содержимого из шаблона,
// iScroll в наследниках RAD.Blanks.ScrollableView при первом отображении еще не существует
onEndRender: function () {},

// выполняется пред началом анимации присоединения view,
// iScroll в наследниках RAD.Blanks.ScrollableView уже существует
onStartAttach: function () {},

// выполняется после окончания анимации присоединения view
onEndAttach: function () {},

// выполняется после удаления view из DOM
onEndDetach: function () {},

// выполняется при уничтожении модуля
onDestroy: function () {}
</pre>

    <h4 id="view-callbacks-onInitialize">onInitialize</h4>

<pre class="prettyprint linenums">
onInitialize: function(){ };
</pre>

    <p>Выполняется первым из коллбэков в конце конструктора при создании экземпляра view. Это последний момент, когда можно напрямую задать модулю <a href="file:///Users/michail/site/index.html#model">модель</a>. В дальнейшем необходимо использовать такие методы view, как <strong>bindModel</strong> и <strong>unbindModel</strong>.</p>

    <h4 id="view-callbacks-onStartRender">onStartRender</h4>

<pre class="prettyprint linenums">
onStartRender: function(){ };
</pre>

    <p>Выполняется перед <strong>render()</strong> модуля. На этом этапе HTML-представления модуля еще нет.</p>

    <h4 id="view-callbacks-onEndRender">onEndRender</h4>

<pre class="prettyprint linenums">
onEndRender: function(){ };
</pre>

    <p>Выполняется в <strong>render()</strong> модуля, когда HTML-представление сгенерировано из шаблона. Обработка всего, что связано с HTML (например, вставка дочерних модулей или добавление классов), должна происходить в этом методе.</p>

    <p>Обратите внимание, что <strong>render()</strong> модуля вызывается при первом отображении модуля и при каждом изменении модели модуля, на которую он автоматически биндится при создании. Возможно также вручную вызвать <strong>render()</strong> модуля.</p>

    <h4 id="view-callbacks-onNewExtras">onNewExtras</h4>

<pre class="prettyprint linenums">
var options = {

    extras: {
        hello : &#39;world&#39;
    }

}
this.publish(&#39;navigation.show&#39;, options);

onNewExtras: function(extras){
    console.log(extras.hello);
};
</pre>

    <p>Выполняется при передачи через навигатор новых extras. Идеально подходит для передачи новой модели или параметров отображаемого модуля. Принимает параметр <strong>extras</strong>.</p>

    <h4 id="view-callbacks-onStartAttach">onStartAttach</h4>

<pre class="prettyprint linenums">
onStartAttach: function(channel, options){ };
</pre>

    <p>Выполняется <strong>перед</strong> отображением модуля и <strong>перед</strong> началом анимации (даже если ее нет). В качестве параметров принимает канал, по которому пришло сообщение, и данные от плагина <a href="file:///Users/michail/site/index.html#navigation_plugin">navigation</a>.</p>

    <h4 id="view-callbacks-onEndAttach">onEndAttach</h4>

<pre class="prettyprint linenums">
    onEndAttach: function(channel, options){ };

                    </pre>

    <p>Выполняется <strong>после</strong> окончания отображения модуля и <strong>после</strong> окончания анимации (даже если ее нет). В качестве параметров принимает канал, по которому пришло сообщение, а также данные от плагина <a href="file:///Users/michail/site/index.html#navigation_plugin">navigation</a>.</p>

    <h4 id="view-callbacks-onEndDetach">onEndDetach</h4>

<pre class="prettyprint linenums">
onEndDetach: function(channel, options){ };
</pre>

    <p>Выполняется после окончательного отсоединения модуля из текущего DOM. В качестве параметров принимает канал, по которому пришло сообщение, и данные от плагина <a href="file:///Users/michail/site/index.html#navigation_plugin">navigation</a>.</p>

    <h4 id="view-callbacks-onDestroy">onDestroy</h4>

<pre class="prettyprint linenums">
onDestroy: function(){ };
</pre>

    <p>Вызывается перед уничтожением экземпляра модуля (деструктор). Нет входных параметров.</p>

    <h4 id="view-callbacks-onReceiveMsg">onReceiveMsg</h4>

<pre class="prettyprint linenums">
    onReceiveMsg: function(msg, data){ };
</pre>

    <p>Модуль при создании автоматически подписывается на сообщения, начинающиеся с &quot;view.&quot; и его имени, например, модуль myModule подпишется как на сообщения &quot;view.myModule&quot;, так и на &quot;view.myModule.doSomeAction&quot;.<br />
        Параметры:<br />
        <strong>msg</strong> - канал сообщения, строка;<br />
        <strong>data</strong> - объект переданных данных (см. публикацию сообщений <a href="file:///Users/michail/site/index.html#publish">publish</a>).</p>

    <p>Сервисы аналогично подписываются на сообщения, начинающиеся с <strong>&quot;service.&quot; + &quot;имя_модуля&quot;</strong></p>

    <h4 id="view-callbacks-loader-done">loader.done</h4>

<pre class="prettyprint linenums">
onNewExtras: function (extras) {
    var self = this;
    self.loader.done(function () {
        self.$(&quot;#options&quot;).html(extras.data);
    });
},
</pre>

    <p>Это не совсем коллбэк-метод. Каждый модуль имеет deferred-объект <strong>loader</strong>, которому возможно передать функцию, которая выполнится после загрузки HTML-представления модуля. В случае, если HTML или HTML-шаблон были загружены, функция выполнится сразу. Например, можно использовать этот метод тогда, когда переданные через <a href="file:///Users/michail/site/index.html#onNewExtras">extras</a> данные необходимо вставить в готовый HTML.</p>

    <h3 id="view-properties">Свойства View</h3>

    <p>Модули унаследованы от <a href="http://backbonejs.org/#View" target="_blank">backbone.view</a>, здесь описаны только некоторые свойства.</p>

    <h4 id="view-properties-url">url</h4>

<pre class="prettyprint linenums">
url: &#39;source/views/inner/third_widget/third_widget.html&#39;
</pre>

    <p>Ссылка на файл HTML, используемый модулем в качестве шаблона.</p>

    <h4 id="view-properties-tagname">tagName и ClassName</h4>

<pre class="prettyprint linenums">
tagName: &#39;li&#39;,
className: &#39;my_list_item&#39;
</pre>

    <p>Определяют, каким элементом будет представлен контейнер модуля и его класс(ы).</p>

    <h4 id="view-properties-children">children</h4>

<pre class="prettyprint linenums">
children:[
    {
        container_id: &#39;.sidebar&#39;,
        content: &#39;view.sidebar_menu&#39;,
    },
    {
        container_id: &#39;.content&#39;,
        content: &#39;view.default_content&#39;,
    }
]
</pre>

    <p>Массив дочерних модулей, которые будут загружены и показаны вместе с родительским. Атрибуты аналогичны <strong>&#39;navigation.show&#39;</strong>.</p>

    <h4 id="view-properties-events">events</h4>

<pre class="prettyprint linenums">
events:{
    &#39;focus .search-by-name&#39;: &#39;showAutocomplete&#39;,
    &#39;click .my_button&#39;:&#39;buttonAction&#39;
},
buttonAction: function(e){
    console.log(e.currentTarget + &#39; clicked&#39;);
},
showAutocomplete: function(){}
</pre>

    <p>Подписка элементов модуля на события.</p>

    <h4 id="view-properties-model">model</h4>

<pre class="prettyprint linenums">
//декларативный способ
model: RAD.models.noteList;

//задание модели при инициализации

onInitialize: function () {
    &quot;use strict&quot;;

    this.model = RAD.models.noteList;
    this.model.add([
        {title:&#39;test note 1&#39;, &#39;description&#39;:&#39;test note description 1&#39;},
        {title:&#39;test note 2&#39;, &#39;description&#39;:&#39;test note description 2&#39;},
        {title:&#39;test note 3&#39;, &#39;description&#39;:&#39;test note description 3&#39;}
    ]);
},
</pre>

    <p>Задает модель данных для модуля. Подробнее о моделях в разделе <a href="file:///Users/michail/site/index.html#model">model</a>. View автоматически подписывается на события модели.</p>

    <h4 id="view-properties-other">произвольные свойства</h4>

<pre class="prettyprint linenums">
currentPageDisplay: 2,
showMyCustomWidget: false
</pre>

    <p>Для хранения состояний модуля можно создавать и использовать любые свойства.</p>

    <p>Следите за тем, чтобы создаваемые свойства не переопределяли имена уже существующих - это может привести к ошибкам.</p>

    <h3 id="view-animation">Animation</h3>

    <p>Вид анимации, используемой при отображении модулей. Возможны следующие значения:</p>

    <ul>
        <li>
            <p>&#39;slide&#39; или &#39;slide-in&#39; (абсолютно аналогично) - новый модуль выезжает справа, старый заезжает влево;</p>
        </li>
        <li>
            <p>&#39;slide-out&#39; - анимация, противоположная &#39;slide-in&#39;;</p>
        </li>
        <li>
            <p>&#39;fade&#39; - альфа-анимация; старый модуль затухает, а новый проявляется;</p>
        </li>
        <li>
            <p>&#39;none&#39; - без анимации, новый модуль просто вставляется вместо старого;</p>
        </li>
        <li>
            <p>не определено - выставляется по умолчанию &#39;slide&#39;.</p>
        </li>
    </ul>

<pre class="prettyprint linenums">
/* Возможно использование кастомной анимации, */
/* для этого необходимо описать в CSS анимацию, подобную следующей */
/* суффиксы -in и -out говорят о направлении */
.new-page.fade-in,
.new-page.fade-out {
    opacity: 0;

    -webkit-transition: opacity 350ms ease;
    -moz-transition: opacity 350ms ease;
    -ms-transition: opacity 350ms ease;
    -o-transition: opacity 350ms ease;
    transition: opacity 350ms ease;
}

.old-page.fade-in,
.old-page.fade-out {
    opacity: 1;

    -webkit-transition: opacity 175ms 175ms ease;
    -moz-transition: opacity 175ms 175ms ease;
    -ms-transition: opacity 175ms 175ms ease;
    -o-transition: opacity 175ms 175ms ease;
    transition: opacity 175ms 175ms ease;
}

.animate &gt; .new-page.fade-in,
.animate &gt; .new-page.fade-out {
    opacity: 1;
}

.animate &gt; .old-page.fade-in,
.animate &gt; .old-page.fade-out {
    opacity: 0;
}
</pre>

    <h2 id="view-template">Шаблоны</h3>

    <p>Шаблоны полезны при рендеринге объемных и сложных частей HTML-разметки из JSON-данных. Для осуществления шаблонизации используется метод из библиотеки <a href="http://underscorejs.org/#template" target="_blank">Underscore.js</a>, который компилирует шаблоны в функции, которые могут быть вызваны для рендеринга этого шаблона. Путь к HTML-шаблону передается в качестве свойства <a href="file:///Users/michail/site/index.html#url">url</a> при обьявлении модуля <a href="file:///Users/michail/site/index.html#view">View</a>. При рендеринге HTML-представления модуля в функцию-шаблонизатор передается <a href="file:///Users/michail/site/index.html#view_model">view.model</a> этого модуля, преобразованная в JSON-объект.</p>

    <p>Пример разметки с шаблонами:</p>

<pre class="prettyprint linenums">
&lt;div class=&quot;scroll-view-body&quot;&gt;
    &lt;div class=&quot;block&quot;&gt;
        &lt;div class=&quot;block-title&quot;&gt;
            &lt;h2&gt;All Action Items&lt;/h2&gt;
        &lt;/div&gt;
        &lt;ul class=&quot;list-items-view&quot;&gt;
            {{# _(model).each(function(action) { }}
            &lt;li &gt;
                &lt;span class=&quot;priority-indicator {{ action.priority }}&quot;&gt;&lt;/span&gt;
                &lt;div class=&quot;list-item-row row-title&quot;&gt;
                    &lt;div class=&quot;info&quot;&gt;{{ action.title }}&lt;/div&gt;
                    &lt;div class=&quot;details&quot;&gt;Due: {{ action.due }}&lt;/div&gt;
                &lt;/div&gt;
                &lt;div class=&quot;list-item-row&quot;&gt;
                    &lt;div class=&quot;info&quot;&gt;Patient: {{ action.patient }} (DOB: {{ action.dob }} )&lt;/div&gt;
                    &lt;div class=&quot;details&quot;&gt;CM Program: {{ action.cm_program }}&lt;/div&gt;
                &lt;/div&gt;
            &lt;/li&gt;
            {{# }); }}
        &lt;/ul&gt;
    &lt;/div&gt;
&lt;/div&gt;
</pre>

    <p>Синтаксис внутри шаблона:</p>

    <ul>
        <li>
            <p><strong>{{ ... }}</strong> - для интерполяции переменных;</p>
        </li>
        <li>
            <p><strong>{{# ... }}</strong> - для выполнения вычислений (JavaScript-код внутри шаблона);</p>
        </li>
        <li>
            <p><strong>{{{ ... }}}</strong> - для экранирования спец-символов (HTML-escaped);</p>
        </li>
        <li>
            <p><strong>model</strong> - преобразованная в JSON-объект <a href="file:///Users/michail/site/index.html#view_model">view.model</a>.</p>
        </li>
    </ul>

    <p>У переданного в шаблон объекта <strong>model</strong> отсутствуют свойства и методы <a href="http://backbonejs.org/#Model" target="_blank">Backbone.Model</a> и <a href="http://backbonejs.org/#Collection" target="_blank">Backbone.Collection</a>. Если необходимо получить доступ непосредственно к <a href="file:///Users/michail/site/index.html#view_model">view.model</a>, либо к другим свойствам и методам, можно использовать прямую ссылку <strong>this</strong> на текущий view внутри шаблона.</p>

    <p>Для построения HTML из большого массива данных удобно использовать <a href="http://backbonejs.ru/#Collection-Underscore-Methods" target="_blank">методы</a> библиотеки Underscore, такие как <strong>each()</strong>, <strong>sortBy()</strong>, <strong>filter()</strong> и т.д.</p>

    <p>Пример использования методов Underscore.js в шаблоне</p>

<pre class="prettyprint linenums">
RAD.view(&quot;view.persons_list&quot;, RAD.Blanks.View.extend({
    url: &quot;source/views/persons_list.html&quot;,
    onInitialize: function () {
        this.model = RAD.model(&#39;persons&#39;, Backbone.Collection, true);
        this.model.add([
            {&quot;firstName&quot;: &quot;John&quot;, &quot;lastName&quot;: &quot;Doe&quot;},
            {&quot;firstName&quot;: &quot;Homer&quot;, &quot;lastName&quot;: &quot;Simpson&quot;},
            ...
            ...
            {&quot;firstName&quot;: &quot;Fox&quot;, &quot;lastName&quot;: &quot;Mulder&quot;}
        ]);
    }
}));

&lt;!-- Шаблон persons_list.html: --&gt;
&lt;ul class=&quot;persons_list&quot;&gt;
    {{# _(model).each(function (person) { }}
    &lt;li&gt;{{ person.firstName }} &lt;b&gt;{{ person.lastName }}&lt;/b&gt;&lt;/li&gt;
    {{# }); }}
&lt;/ul&gt;

&lt;!-- После шаблонизации: --&gt;
&lt;ul class=&quot;persons_list&quot;&gt;
    &lt;li&gt;John &lt;b&gt;Doe&lt;/b&gt;&lt;/li&gt;
    &lt;li&gt;Homer &lt;b&gt;Simpson&lt;/b&gt;&lt;/li&gt;
    ...
    ...
    &lt;li&gt;Fox &lt;b&gt;Mulder&lt;/b&gt;&lt;/li&gt;
&lt;/ul&gt;
</pre>

    <p>Для того, чтобы при изменении <strong>model</strong> была перерисована лишь часть модуля, контейнеру, содержащему шаблон, необходимо присвоить атрибут <strong>data-template</strong>.</p>

    <p>Пример использования атрибута <strong>data-template</strong>:</p>

<pre class="prettyprint linenums">
&lt;div id=&quot;my_module&quot;&gt;
    &lt;!-- содержимое &lt;div&gt; не будет перерисовано (радиокнопка не будет сброшена в положение по умолчанию) --&gt;
    &lt;div class=&quot;controls&quot;&gt;
        &lt;p&gt;Sort by:&lt;/p&gt;
        &lt;label&gt;&lt;input type=&quot;radio&quot; name=&quot;sort_by&quot; value=&quot;first_name&quot; /&gt;First Name&lt;/label&gt;
        &lt;label&gt;&lt;input type=&quot;radio&quot; name=&quot;sort_by&quot; value=&quot;last_name&quot; checked /&gt;Last Name&lt;/label&gt;
    &lt;/div&gt;
    &lt;!-- содержимое &lt;ul&gt; будет перерисовано --&gt;
    &lt;ul class=&quot;persons_list&quot; data-template&gt;
        {{# _(model).each(function (person) { }}
        &lt;li&gt;{{ person.firstName }} &lt;b&gt;{{ person.lastName }}&lt;/b&gt;&lt;/li&gt;
        {{# }); }}
    &lt;/ul&gt;
&lt;/div&gt;
</pre>

    <h2 id="view-toast">Toast</h2>

    <p>Модуль для оповещений, автоматически закрывающийся через определенное время (по умолчанию - 3 секунды). См. <a href="file:///Users/michail/site/index.html#navigation_toast_show">navigation.toast.show</a>.</p>

<pre class="prettyprint linenums">
RAD.view(&quot;view.CompleteToast&quot;, RAD.Blanks.Toast.extend({
    //шаблон
    url: &#39;source/views/start_page.html&#39;,
    //время показа
    showTime: 5000
}));
</pre>

    <p>Обратите внимание: элемент модуля <strong>toast</strong> помещается в <strong>body</strong>, игнорируя <strong>container_id</strong> в опциях <a href="file:///Users/michail/site/index.html#navigation_plugin">navigation</a>.</p>

    <h2 id="view-popup">Popup</h2>

    <p>Модуль реализует самопозиционирующийся popup. Способы позиционирования задаются в опциях <a href="file:///Users/michail/site/index.html#navigation_popup_show">navigation.popup.show</a>.</p>

<pre class="prettyprint linenums">
RAD.view(&quot;view.PopupOverview&quot;, RAD.Blanks.Popup.extend({
    url: &#39;source/views/popup_dashboard_overview/popup_dashboard_overview.html&#39;,

    onInitialize: function (){
        var Model = Backbone.Model.extend();

        this.model = new Model();
    },
    onNewExtras: function (extras) {
        &#39;use strict&#39;;

        this.model.set({msg: extras});
    },
    // будет ли popup закрываться по клику вне модуля
    outSideClose: true,
    // будет ли уничтожаться инстанс модуля при закрытии (по умолчанию - уничтожается)
    // если не надо уничтожать - прописать следующую строку
    onCloseDestroy: false
});
</pre>

    <p>Обратите внимание: элемент модуля <strong>popup</strong> помещается в <strong>body</strong>, игнорируя <strong>container_id</strong> в опциях <a href="file:///Users/michail/site/index.html#navigation_plugin">navigation</a>.</p>

    <h2 id="view-scroll">Scrollable view</h2>

    <p>Модуль со скроллящимся контентом, использует доработанную версию <a href="http://cubiq.org/iscroll-4">iScroll-lite</a>.</p>

<pre class="prettyprint linenums">
RAD.view(&quot;view.start_page&quot;, RAD.Blanks.ScrollableView.extend({
    url: &#39;source/views/start_page.html&#39;
}));
</pre>

    <p>Обратите внимание, что для работы iScroll&#39;а необходимо наличие в HTML класса <strong>&quot;scroll-view&quot;</strong> для контейнера, в котором скролится контент (при наследовании от ScrollableView он автоматически вешается на весь view).<br />
        Для правильной работы скролла при изменении размера скроллящегося контента, для его контейнера необходим установленный атрибут <strong>data-template</strong>.</p>

    <h2 id="view-models">Model</h2>

    <p>В качестве модели данных используется <a href="http://backbonejs.org/#Model" target="_blank">backbone.model</a>.</p>

<pre class="prettyprint linenums">
//создание модели
RAD.model(&#39;name&#39;, &lt;backbone.model&gt;, [instantiate]);

//получение модели (вернет undefined, если модели нет)
RAD.model(&#39;name&#39;);
</pre>

    <p>Для работы с моделями вызывается метод RAD.model(...), где используются следующие параметры:</p>

    <ul>
        <li>
            <p><strong>name</strong> - имя модели, под которым в RAD.models будет создана модель. Может быть задано в виде:<br />
                &lt;namespace&gt;.&lt;subnamespace&gt;.name</p>
        </li>
        <li>
            <p><strong>backbone.model</strong> - модель backbone (пример ниже);</p>
        </li>
        <li>
            <p><strong>instantiate</strong> - параметр создания модели. <strong>true</strong> (или не передан) - создать экземпляр, <strong>false</strong> - сохранить как конструктор.</p>
        </li>
    </ul>

    <p>Создание конструктора модели:</p>

<pre class="prettyprint linenums">
RAD.model(&#39;note&#39;, Backbone.Model.extend({defaults: {
        title: &quot;-&quot;,
        description: &quot;-&quot;
    }
}), false);
</pre>

    <p>Создание модели в модуле:</p>

<pre class="prettyprint linenums">
onInitialize: function () {
    &quot;use strict&quot;;
    var md = RAD.model(&#39;note&#39;);
    this.model = new md();
    this.model.set({title:&#39;test note 1&#39;, &#39;description&#39;:&#39;test note description 1&#39;})
},
</pre>

    <p>Использование модели в шаблоне:</p>

<pre class="prettyprint linenums">
&lt;div class=&quot;my page&quot;&gt;
    &lt;h3&gt;Use models, Luke!&lt;/h3&gt;
    &lt;div id=&quot;title&quot;&gt;{{ model.title }}&lt;/div&gt;
    &lt;div id=&quot;description&quot;&gt;{{ model.description }}&lt;/div&gt;
&lt;/div&gt;
</pre>

    <p>При изменении модели будет вызван метод <strong>render()</strong> модуля и автоматически обновится <strong>ВСЕ</strong> его содержимое. Для того, чтобы при изменении модели была перерисована лишь часть модуля, контейнеру, содержащему шаблон, необходимо присвоить атрибут <strong>data-template</strong> (см. примеры в разделе <a href="file:///Users/michail/site/index.html#templates">&quot;Шаблоны&quot;</a>).</p>

    <h3 id="view-models-model">Модель уровня приложения</h3>

    <p>Если необходимо, чтобы модель была доступна нескольким модулям, можно создать экземпляр модели на уровне приложения, передав последним параметром true.</p>

    <p>Создание экземпляра модели:</p>

<pre class="prettyprint linenums">
RAD.model(&#39;message&#39;, Backbone.Model.extend({
        defaults: {
            title: &quot;-&quot;,
            description: &quot;-&quot;
        }
}), true);
</pre>

    <p>Изменение данных модели:</p>

<pre class="prettyprint linenums">
RAD.model(&#39;message&#39;).set({title: &#39;new note&#39;, description: &#39;lorem ipsum dolor&#39;});
</pre>

    <h2 id="service">Service</h2>

    <p>Сервисы не имеют визуального представления, и могут быть использованы для обработки внутренней логики приложения. Имеют некоторые callback-методы, аналогичные <strong>view</strong>; также могут иметь <a href="file:///Users/michail/site/index.html#custom_properties">произвольные свойства</a>.</p>

    <h3 id="service-declaration">Объявление</h3>

    <p>Сервисы объявляются аналогично модулям, и тоже инстанциируются при получении первого сообщения.</p>

<pre class="prettyprint linenums">
RAD.service(&quot;service.my_service&quot;, RAD.Blanks.Service.extend({
    onReceiveMsg: function (channel, data) {
        &quot;use strict&quot;;
        var backway = data.split(&quot;&quot;).reverse().join(&quot;&quot;);
        this.publish(&#39;view.widget2&#39;, backway);
    }
}));
</pre>

    <h2 id="service-callbacks">Callbacks</h3>

    <p>Коллбэки сервисов аналогичны <a href="file:///Users/michail/site/index.html#callbacks">view callbacks</a>, но из-за отсутствия визуального представления применимы не все.</p>

    <h4 id="service-callbacks-onInitialize">onInitialize</h4>

<pre class="prettyprint linenums">
onInitialize: function(){ };
</pre>

    <p>Выполняется первым из коллбэков в конце конструктора при создании экземпляра service. Это последний момент, когда можно напрямую задать модулю <a href="file:///Users/michail/site/index.html#model">модель</a>. В дальнейшем необходимо использовать такие методы view, как <strong>bindModel</strong> и <strong>unbindModel</strong>.</p>

    <h4 id="service-callbacks-onDestroy">onDestroy</h4>

<pre class="prettyprint linenums">
onDestroy: function(){ };
</pre>

    <p>Вызывается перед уничтожением экземпляра сервиса (деструктор). Нет входных параметров.</p>

    <h4 id="service-callbacks-onReceiveMsg">onReceiveMsg</h4>

<pre class="prettyprint linenums">
onReceiveMsg: function(msg, data){ };
</pre>

    <p>Сервис при создании автоматически подписывается на сообщения, начинающиеся с &quot;service.&quot; и его имени. Аналогично <a href="file:///Users/michail/site/index.html#onReceiveMsg">module.onReceiveMsg</a><br />
        Параметры:<br />
        <strong>msg</strong> - канал сообщения, строка;<br />
        <strong>data</strong> - объект переданных данных (см. публикацию сообщений <a href="file:///Users/michail/site/index.html#publish">publish</a>).</p>

    <h2 id="namespace">Namespace</h2>

    <p>Фреймворк позволяет использовать шаблон <strong>&#39;namespace&#39;</strong> (пространства имен) для структурированного хранения собственных конструкторов <strong>models</strong>, <strong>views</strong>, <strong>services</strong> и т.д., или наследования от существующих.</p>

<pre class="prettyprint linenums">
RAD.namespace(destination, [obj]);
</pre>

    <ul>
        <li>
            <p><strong>destination</strong> - местонахождение namespace</p>
        </li>
        <li>
            <p><strong>obj</strong> - объект, который будет определен в этом namespace</p>
        </li>
    </ul>

<pre class="prettyprint linenums">
//Создание объекта authServer в пространстве имен RAD.network.nodes
RAD.namespace(&#39;network.nodes.authServer&#39;, {name: &#39;AuthServer&#39;, baseUrl: &#39;http://192.168.1.1/&#39;});

//Создаст в пространстве RAD.utils метод getRndInt
RAD.namespace(&#39;RAD.utils.getRndInt&#39;, function (min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
});

RAD.namespace(&#39;RAD.models.toDoList&#39;, Backbone.Collection.extend({
    comparator: function (task) {
      return task.get(&quot;name&quot;);
    }
}));

//Пример наследования view от RAD.Blanks.ScrollableView и последующего его объявления.
RAD.namespace(&#39;RAD.views.ListView&#39;, RAD.Blanks.ScrollableView.extend({
    model: new RAD.models.toDoList
}));
RAD.view(&#39;view.todo_list&#39;, RAD.views.ListView);
</pre>

    <p>Обратите внимание: если при наследовании view в качестве прототипа выступает не RAD.Blanks.View, а Backbone.View, то view-наследник не будет иметь <a href="file:///Users/michail/site/index.html#callbacks">callback-методов</a> <strong>RAD.Blanks.View</strong>.</p>

    <p>Фреймворком предоставляются для использования готовые <strong>namespace</strong>:</p>

    <ul>
        <li>
            <p><strong>RAD.Class</strong> - для собственных классов;</p>
        </li>
        <li>
            <p><strong>RAD.models</strong> - для моделей и коллекций;</p>
        </li>
        <li>
            <p><strong>RAD.views</strong> - для конструкторов View;</p>
        </li>
        <li>
            <p><strong>RAD.services</strong> - для сервисов;</p>
        </li>
        <li>
            <p><strong>RAD.plugins</strong> - для плагинов;</p>
        </li>
        <li>
            <p><strong>RAD.utils</strong> - для полезных методов-утилит.</p>
        </li>
    </ul>

    <h2 id="">FAQ</h2>

    <p>Часто задаваемые вопросы.</p>

    <ul>
        <li>
            <p>Как узнать, какие view видны на экране?</p>

	<pre class="prettyprint linenums">
    querySelectorAll(&laquo;[view]&raquo;);
                                </pre>
        </li>
        <li>
            <p>Как получить ссылку на HTML-элемент-контейнер, в котором находится view?</p>

	<pre class="prettyprint linenums">
    querySelector(&laquo;[view=&#39;viewID&#39;]&raquo;);
                                </pre>
        </li>
        <li>
            <p>Как получить список всех view, экземпляры которых созданы?</p>

	<pre class="prettyprint linenums">
    RAD.core.getStartedViews();
                                </pre>

            <p>К счастью (или к сожалению), у нас пока не было не одного реально необходимого случая для вызова данного метода.</p>

            
        </li>
        <li>
            <p>Получение экземпляра любого модуля приложения.</p>

            <p>В любой части приложения возможно получить непосредственную ссылку на любой зарегистрированный модуль приложения (view или сервис) через прямую ссылку на ядро:</p>

	<pre class="prettyprint linenums">
    RAD.core.getView(viewID, extras);
                                
    RAD.core.getService(viewID);
                                </pre>

            <p>Учтите, что архитектура приложения на <strong>RAD.js</strong> рассчитана на слабую связанность модулей и динамическое создание/уничтожение частей приложения, поэтому использовать данный механизм не рекомендуется.<br />
                Связано это с тем, что данные методы вернут вам ссылку на экземпляр уже существующего модуля с указанным ID, или же создадут новый. Если вы сохраните эту ссылку, например, в атрибуте вашего view, какая-нибудь другая часть вашего приложения (опять же, через методы ядра) может удалить экземпляр модуля, а потом создать его уже с другими данными или моделью.<br />
                Итогом будет наличие сильной связи, наличие ссылки на модуль, который уже уничтожен и нигде больше не используется.   В качестве рекомендации можно предложить использовать методы ядра только в объекте приложения. В этом случае вся работа по созданию и уничтожению модулей будет сосредоточена в одном месте, и найти логическую ошибку будет намного легче.</p>

            
        </li>
        <li>
            <p>Модули являются Backbone.View?</p>

            <p>Нет, но они созданы на основе Backbone.View и имеют почти те же задачи, основная из которых - отображение модуля на странице</p>

            
        </li>
        <li>
            <p>Что такое канал (<strong>channel</strong>)? У каждого модуля свой channel? Как происходит <strong>subscribe</strong> и <strong>publish</strong> в определенный channel? В канал публикуется просто некое сообщение, и модуль, который слушает канал в ожидании этого сообщения, должен на него среагировать?</p>

            <p>Канал является совокупностью публикатора, модуля подписчика и медиатора. Сообщениями, которыми обмениваются эти компоненты, являются события (&ldquo;команды&rdquo;, &ldquo;намерения&rdquo;).</p>

            
        </li>
        <li>
            <p>Что такое <strong>extras?</strong></p>

            <p>Дополнительные данные, которые передаются во view при публикации сообщения через navigator.</p>

            
        </li>
        <li>
            <p>На какие сообщения подписываются модули при регистрации?</p>

            <p>На события, имя которых начинается с <strong>&quot;view.&quot; + имя модуля</strong>. При публикации такого сообщения вызывается <a href="file:///Users/michail/site/index.html#onReceiveMsg">onReceiveMsg</a> этого модуля.</p>

            
        </li>
        <li>
            <p>Что такое <strong>backstack</strong>? Как именно работает и какие свойства нужно задать для его правильной работы?</p>

            <p>Это компонент плагина <strong>router</strong>, позволяющий динамически запоминать расположение (т.е. layout) views на экране для конкретной сессии, используя <em>history API</em> браузера либо внутреннюю реализацию - и таким образом возвращаться к предыдущим расположениям модулей.<br />
                <br />
                Для использования бэкстека достаточно указать параметр <strong>backstack: true</strong> в запросе на смену views. Более подробная информация в разделе <a href="file:///Users/michail/site/index.html#router_backstack">backstack</a>.</p>

            
        </li>
        <li>
            <p>Будет ли работать анимация дочерних модулей, если задать её таким образом? Например:</p>

	<pre class="prettyprint linenums">
    RAD.views.ParentWidget = RAD.Blanks.View.extend({
        url: &#39;source/views/parent_widget/parent_widget.html&#39;,
        children: [
            {
                container_id: &#39;.content&#39;,
                content: &quot;view.inner_first_widget&quot;,
                animation: &#39;slide&#39;
            },
            {
                container_id: &#39;.top&#39;,
                content: &quot;view.inner_third_widget&quot;,
                animation: &#39;fade&#39;
            }
        ]
    });
                                </pre>

            <p>Да, но использовать не рекомендуется - будет визуально некрасиво.</p>

            
        </li>
        <li>
            <p>Что происходит с дочерними модулями (&#39;&#39;children&#39;&#39;) во время рендеринга родительского модуля?</p>

            <p>Во время самого первого рендеринга родительского модуля происходит следующее:</p>

            <ul>
                <li>
                    <p>Выполняется коллбэк <strong>onStartRender()</strong> (если определен);</p>
                </li>
                <li>
                    <p>Происходит рендер модуля;</p>
                </li>
                <li>
                    <p>Происходит присоединение (attach) дочерних модулей;</p>
                </li>
                <li>
                    <p>Выполняется коллбэк <strong>onEndRender()</strong> (если определен).</p>
                </li>
            </ul>

            <p><br />
                Во время повторного рендеринга в порядок действий добавляется предварительное отсоединение дочерних модулей:</p>

            <ul>
                <li>
                    <p>Выполняется коллбэк <strong>onStartRender()</strong> (если определен);</p>
                </li>
                <li>
                    <p>Происходит отсоединение (detach) дочерних модулей;</p>
                </li>
                <li>
                    <p>Происходит рендер модуля;</p>
                </li>
                <li>
                    <p>Происходит присоединение (attach) дочерних модулей;</p>
                </li>
                <li>
                    <p>Выполняется коллбэк <strong>onEndRender()</strong> (если определен).</p>
                </li>
            </ul>

            <p>Таким образом, заново рендерится только родительский модуль, а &#39;&#39;children&#39;&#39; - нет.</p>

            
        </li>
        <li>
            <p>Можно ли &quot;прикрепить&quot; iScroll к какому либо дочернему HTML-элементу модуля при отображении этого модуля?</p>
            <p>Да, контейнеру для iScroll необходимо указать класс &quot;<strong>scroll-view</strong>&quot;.</p>
        </li>
        <li>
            <p>Какие существуют события iScroll?</p>
            <p>См. события в документации iScroll4.</p>
        </li>
    </ul>

    

    

	</div>
</div>
<script src="../prettify/prettify.js"></script>
<script src="../js/jquery-1.10.2.min.js"></script>
<script src="../js/main.js"></script>

<script>prettyPrint();</script>

		
</body>
</html>